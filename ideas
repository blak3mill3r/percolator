can bits of percolator internals be refactored for simmplicity w/ definterpreter?
no, bad idea, because
definterpreter is for making macro-ey forms that build percolator forms
no real need for it in core I think
maybe there will be, but percolator internals now (defn interpret-expression-*) are fine


scopes generic is what matters most...
scopes built in to percolator:
statement body-decl expression
that's it I think


thoughts on the multimethod inf
which is to allow clojure literals
to be translated into java-literal-expression clojure expressions
and I want it to allow user to override somehow
defining for a given scope what to do with a java.lang.Double


so now it's a multimethod dispatching on the class of form
that's correctish...
but those need to be made generic and respect scopes hierarchy


right now my scopes hierarchy is a map of scope-name-symbol
to maps of first-forms to functions

that way the maps for each scope can be
key-> either one of
  '(quote foo)
  java.lang.String

THAT IS GOOD


maybe instead of interpret-in-scope being the multimethod
interpreter-for-scope-and-form could be
that sounds better

YAY it works
no multimethod at all, just doing it manually
in interpreter-for-scope-and-form


this is pretty good
now you have scope :expression working


One thing I should fix

the keys '(quote break)
that's dumb
because every single form which is seq?
has to look through that
instead it should look at the form and see if it's first is a list beginning with the literal symbol quote
and iff so, do the map lookup
FIX THAT
DONE fixed

now to refactor expression.clj



done, and done with body-decl

good stuff


now for statement
which needs inheritance from expression

so current scopes definition needs to be changed

instead of

{:expression {'this this-expr}
 :statement {}
}


{:expression { :interpreters {'this this-expr} }
 :statement { :interpreters { 'break break-stmt }
              :inherits { :expression expr-to-stmt } }
}


what if I leave scope def as is
and have 1 more data structure to describe inheritance?

(def scope-inheritance
  { :statement [ :expression (fn [expr] `(new ExpressionStmt ~expr)) ] }
)

good stuff
make it wrap
then do statement

PASTED FROM test.clj

      ;( 'add ( '>RootPanel/nameFieldContainer ) nameField )
        ; cool idea
        ; if a symbol starts with a special character like > above
        ; it is a special gwt-specific expression
        ; such as apanel.get("a_domid")

      ; would be nice if above could be written
      ;( 'doto nameField
      ;  ('focus)
      ;  ('select-all))

      ; rewrite above as
      ; NOTE: this is purely imaginary
      ;   (comment

      ;( 'vpanel dialogVPanel )

      ;    ; a series of panel manipulations
      ;    ; so '<-- would be a statement interpreter
      ;    ; producing a BlockStmt
      ;    ; kinda like a doto but the forms are panel manipulations
      ;( '<-- dialogVPanel
      ;  :.dialogVPanel             ; keyword starting with . css style name
      ;  :#foo                      ; keyword starting with # dom id
      ;  "<b>Sending name etc </b>" ; straight HTML
      ;  textToServerLabel          ; symbol not beginning with . is a widget to add
      ;  [ :b "Server Response" ]   ; hiccup, would be insanely cool to support run-time variables in here
      ;  serverResponseLabel        
      ;  :align-right               ; keyword are special syntax that map to special things like setHorizontalAlignment VerticalPanel/ALIGN_RIGHT
      ;)

      ;     )

      ; back to stuff that works...

